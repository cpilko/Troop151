// Generated by CoffeeScript 1.7.0
(function() {
  var Helpers, W, fs, glob, nodefn, path, rimraf, run, _;

  require('colors');

  fs = require('fs');

  path = require('path');

  glob = require('glob');

  rimraf = require('rimraf');

  W = require('when');

  nodefn = require('when/node');

  run = require('child_process').exec;

  _ = require('lodash');


  /**
   * @class Helpers
   * @classdesc a collection of useful test helper functions for
   * roots extensions
   */

  Helpers = (function() {
    function Helpers(opts) {
      var _path;
      if (opts == null) {
        opts = {};
      }
      _path = function(f) {
        if (opts.base != null) {
          return path.join(opts.base, f);
        } else {
          return path.normalize(f);
        }
      };
      this.file = {
        exists: function(f) {
          return fs.existsSync(_path(f));
        },
        doesnt_exist: function(f) {
          return !fs.existsSync(_path(f));
        },
        has_content: function(f) {
          return fs.readFileSync(_path(f), 'utf8').length > 0;
        },
        is_empty: function(f) {
          return fs.readFileSync(_path(f), 'utf8').length < 1;
        },
        contains: function(f, content) {
          return fs.readFileSync(_path(f), 'utf8').indexOf(content) > -1;
        },
        contains_match: function(f, regex) {
          return !!fs.readFileSync(_path(f), 'utf8').match(regex);
        },
        matches_file: function(f, expected) {
          f = _path(f);
          expected = _path(expected);
          return String(fs.readFileSync(f)) === String(fs.readFileSync(expected));
        }
      };
      this.directory = {
        is_directory: function(dir) {
          return fs.statSync(_path(dir)).isDirectory();
        },
        exists: function(dir) {
          var err, stat;
          dir = _path(dir);
          try {
            stat = fs.statSync(dir);
          } catch (_error) {
            err = _error;
            return false;
          }
          return stat.isDirectory() && fs.existsSync(dir);
        },
        doesnt_exist: function(dir) {
          return !fs.existsSync(_path(dir));
        },
        has_contents: function(dir) {
          return fs.readdirSync(_path(dir)).length > 0;
        },
        is_empty: function(dir) {
          return fs.readdirSync(_path(dir)).length < 1;
        },
        contains_file: function(dir, file) {
          return _.contains(fs.readdirSync(_path(dir)), file);
        },
        matches_dir: function(dir, expected) {
          dir = _path(dir);
          expected = _path(expected);
          return String(fs.readdirSync(dir)) === String(fs.readdirSync(expected));
        }
      };
      this.project = {
        compile: function(Roots, p) {
          return new Roots(_path(p)).compile();
        },
        remove_folders: function(matcher) {
          var dir, _i, _len, _ref, _results;
          _ref = glob.sync(_path(matcher));
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            dir = _ref[_i];
            _results.push(rimraf.sync(dir));
          }
          return _results;
        },
        install_dependencies: function(base, cb) {
          var d, p, tasks, _i, _len, _ref;
          tasks = [];
          _ref = glob.sync("" + (_path(base)) + "/package.json");
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            d = _ref[_i];
            p = path.dirname(d);
            if (fs.existsSync(path.join(p, 'node_modules'))) {
              continue;
            }
            tasks.push(nodefn.call(run, "npm i", {
              cwd: p
            }));
          }
          if (tasks.length) {
            console.log('installing test dependencies...'.grey);
          }
          return W.all(tasks).then(function() {
            console.log('');
            return cb();
          });
        }
      };
    }

    return Helpers;

  })();

  module.exports = Helpers;

}).call(this);
