// Generated by CoffeeScript 1.7.0
(function() {
  var File, RootsUtil, fs, glob, minimatch, mkdirp, node, path, _;

  path = require('path');

  fs = require('fs');

  node = require('when/node');

  mkdirp = require('mkdirp');

  glob = require('glob');

  _ = require('lodash');

  minimatch = require('minimatch');

  File = require('vinyl');

  RootsUtil = (function() {
    function RootsUtil(roots) {
      this.roots = roots;
    }


    /**
     * Given a path relative to the roots output folder and contents, writes
     * the contents to the given path, recursively creating any directories in
     * the path that have not yet been created.
     *
     * @param  {String} _path - relative path to write destination
     * @param  {String} contents - what to write to the file
     * @return {Promise} a promise for the written file
     */

    RootsUtil.prototype.write = function(_path, contents) {
      var output_path;
      output_path = path.join(this.roots.config.output_path(), _path);
      return node.call(mkdirp, path.dirname(output_path)).then(function() {
        return node.call(fs.writeFile, output_path, contents);
      });
    };


    /**
     * Given a minimatch string or array of minimatch strings, scans the
     * roots project for non-ignored file matches and returns an array of
     * vinyl-wrapped files.
     *
     * @param  {String or Array} files - string or array of minimatch strings
     * @return {Array} all matching files, in vinyl objects
     */

    RootsUtil.prototype.files = function(matchers) {
      var matcher, res, tmp, _i, _len;
      if (!Array.isArray(matchers)) {
        matchers = [matchers];
      }
      res = [];
      for (_i = 0, _len = matchers.length; _i < _len; _i++) {
        matcher = matchers[_i];
        tmp = glob.sync(path.join(this.roots.root, matcher));
        tmp = _.reject(tmp, function(f) {
          return fs.statSync(f).isDirectory();
        });
        tmp = tmp.map((function(_this) {
          return function(f) {
            return new File({
              base: _this.roots.root,
              path: f
            });
          };
        })(this));
        tmp = _.reject(tmp, (function(_this) {
          return function(f) {
            return _.any(_this.roots.config.ignores, function(i) {
              return minimatch(f.relative, i, {
                dot: true
              });
            });
          };
        })(this));
        res = res.concat(tmp);
      }
      return res;
    };


    /**
     * Given the path to a source file in a roots project, produces the output
     * path that it will be written to. Returns a vinyl-wrapped file object.
     *
     * @param  {String} _path - path to a file in the roots project source
     * @param  {String} ext - (optional) file extension override
     * @return {File} vinyl file obj representing where it will be written
     */

    RootsUtil.prototype.output_path = function(_path, ext) {
      var f, out;
      f = new File({
        base: this.roots.root,
        path: path.join(this.roots.root, _path)
      });
      out = ext ? this.roots.config.out(f, ext) : this.roots.config.out(f);
      return new File({
        base: this.roots.config.output_path(),
        path: out
      });
    };


    /**
     * For use with detect, given an extension it will match all files with
     * appropriate extenstions.
     *
     * @param  {File} file - a vinyl file obj passed from detect() function
     * @param  {String or Array} ext - file extension to match
     * @return {Boolean} whether the extension of the file matches the ext arg
     */

    RootsUtil.prototype.with_extension = function(file, ext) {
      return _.contains(Array.prototype.concat(ext), path.extname(file.relative).substr(1));
    };

    return RootsUtil;

  })();

  module.exports = RootsUtil;

  module.exports.Helpers = require('./test_helpers');

}).call(this);
